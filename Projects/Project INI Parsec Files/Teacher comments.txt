Классы следует писать в отдельном файле (.h/.cpp). Шаблонную функцию не всегда можно вынести в единицу трансляции, поэтому её оставляют в заголовочном файле (почитайте почему).

Такие символы/константы ] ; = в коде называются магическими символами. Обычно их выносят в отдельный файл Consts.h, например, выносят в пространство имён namespase Consts и записывают как:


namespase Consts {

const char* isEqualSymbol = "=";
// ...

} // namespase Consts
а так же помечают такие файлы в CMake как предкомпилированные:


if(COMMAND target_precompile_headers)
   target_precompile_headers(${PROJECT_NAME} PUBLIC ./include/Consts.h)
endif()
чтобы увеличить производительность. Ещё один способ спрятать их - при разделении класса на заголовочный файл и единицу трансляции вынести в анонимное пространство имён (в единице трансляции), если нет смысла создавать целый файл.

Советую в будущем почитать правила к стилю написания кода на C++ от Google, чтобы сделать свой код ещё более чистым и читаемым - в командных проектах это очень важно.

При изучении данной темы, я всегда на будущее советую почитать про std::variant, std::optional, std::any - данные контейнеры помогут обойтись без шаблонов, а так же на собеседованиях часто спрашивают про разницу между ними.

Что касается шаблонной функции - в C++ 14 есть удобный механизм (надо будет в сборке указать set(CMAKE_CXX_STANDARD 14)), который может обработать тип в шаблонной функции:


if constexpr (std::is_same_v<T, std::string>) {
  // достаём std::string
}

if constexpr (std::is_same_v<T, int>) {
  // достаём int
}
с подобным механизмом можно обойтись только одной шаблонной функцией.

Можно ещё добавить в конце try/catch (в main):

...
} catch (...) {
  std::cout << "Unknown error" << std::endl;
}
такой общий catch перехватит остальные throw, но не перехватит, например, деление на 0.

Пустой деструктор можно пометить как = default;. Не используемый пустой конструктор по умолчанию можно пометить как = delete;.

Для создания сложных строк (в данном случае логов в консоль) можно использовать std::format из C++20 (может не работать, если не скомпилированы нужные библиотеки):


#include <format>

std::cout << "Integer value: " << int_value << std::endl;
std::cout << "String value: " << string_value << std::endl;

std::cout << std::format("Integer value: {}\nString value: {}\n", int_value, string_value);
Желаю удачи в дальнейшем обучении! Надеюсь мои комментарии помогут Вам в будущем)